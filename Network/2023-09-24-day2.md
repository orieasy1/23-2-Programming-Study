<h1>OSI 7 layer</h1>

공릉에 내가 있고 미국에 A가 있다고 가정하자.
메세지를 A와 내가 주고받기 위해서는 먼저 end to end 연결이 이루어져야한다.
나는 내가 보내고자 하는 메세지를 공릉우체국에 전달할 것이다.
동일 네트워크 내에서 전달할 수 있는 우체국(gateway)로 전달해줘야 할 것.
공릉우체국처럼 동일 네트워크에서 바깥으로 나가는 문을 gateway라고 한다.
<br><br>
공릉우체국에서는 내가 보낸 메세지를 다음 우체국에 전달해준다.: hop by hop
바로 미국으로 전달되지 않는다.
hop by hop으로 하나씩 하나씩 건너간다.
우체국과 우체국(인터넷) 사이에는 규칙이 있는데 이것을 TCP/IP 라는 두개의 규칙이 있다.
end to end 연결도 규칙을 정의해놓았는데 그것이 OSI 7 layer이다.


<h3>OSI 7 layer에 관한 기본적인 내용 정리</h3>
OSI 참조 모델은 네트워크를 통해 어떻게 정보가 전달되는가를 이해할 수 있는 틀을 제공한다.

OSI 7 Layer의 이점에는 , 복잡성 감소, 네트워크 기능 표준화가 있다. 
또 다양한 하드웨어 및 소프트웨어를 기대할 수 있으며 한계층의 내용을 변화시켜도 다른 네트계층의 변화와는 무관하다는 점, 배우는 사람이 쉽게 습득 가능하다는 점이 있다.

* 7: Application
* 6: Presentation
* 5: Session
* 4: Transport
* 3: Network
* 2: Data Link
* 1: Physical

Session부터는 Application까지는 상위계층, Physical부터 Transport까지는 하위계층이라고 칭한다.
상위계층은 데이터 생성계층이고 하위계층은 데이터 전송계층이다.
5-7계층에서 주고 받는 것은 data이고, 4계층에서 주고 받는 내용은 Segments, 3계층은 Packets, 2계층은 Frame, 1계층은 its라고 한다.

과거에는 packet요금제를 사용하다가 현재는 data요금제를 사용하는데 과거와는 전송되는 위치가 달라졌음을 뜻한다. 

7계층에서 데이터를 만들면 이 데이터를 밑의 6계층으로 내려보내게 되고 밑에 계층에서는 head를 붙인다.
head은 안의 데이터 내용을 설명해준다.
6계층에서는 다시 5계층으로 데이터를 내려보내고 5계층에서 다시 head가 붙는다.

head와 tail을 붙이는 것을 인캡슐레이션이라고 한다.
인캡슐레이션: 상위계층에서 하위 계층으로 데이터를 보내면 물리 계층에서 저기 신호 형태로 네트워크를 통해 신호를 보내는 과정 (분할이 일어남)

5계층까지는 데이터 생성계층이고 4계층부터는 데이터 전송계층이다.
데이터 전송이란 택배아저씨가 들고 갈 수 있는 크기, 즉 전송 크기(규격)인 Segments만큼 데이터를 조각내서 데이터를 보낸다는 뜻이다.
조각화가 되어 3계층으로 내려가면 3계층 head가 붙고 2계층으로 내려가면 2계층 head가 붙게된다.

2계층에서는 tail도 붙고 꼬리는 앞의 데이터의 이상 유무를 체크해준다.
꼬리까지 붙은 상태로 1계층으로 내려가서 전기신호로 바뀌어져서 전송하게 된다.
이 신호를 수신하는 장비는 디캡슐레이션이라는 head를 때어내는 과정을 거치며 정보를 위로 올려줄 것이다.

TCP/IP : 인터넷을 하기 위한 프로토콜 집합 <br>
bit, frame, pracket, segment, data <br>
SDU (service data unit) = payload = 헤더를 제외한 값, 계층에 관심이 없을 때 스는 표현이다. 관심이 있었다면 위에 적혀있는대로 표현했을 것. <br>
PDU (protocol data unit) = 헤더를 포함한 값

<br>

<h3>OSI 7 layer 계층별 정리: L7 7계층 </h3>
L7 : 상요자에게 편리한 인터페이스를 정의한 계층 <br>
  * C:\Windows\System32\drivers\etc
  * 규칙들은 위 경로의 하위폴더인 services 파일에 들어가 있다.

<img width="526" alt="image" src="https://github.com/orieasy1/2023-2-WebStudy-backend/assets/129071350/7a6517a1-e1cb-4f99-b804-4ac710c67e56">

여기서 보이는 코드들을 7계층에서 정의내려주는 것이다.

<br><br>

<h3> OSI Layer 계층별 정리: L6 6계층</h3>
L6 : 압축, 포맷, 암호화를 담당
  * 압축에는 손실성 있는 압축은 줄인다라는 의미를 가지고 손실성 없는 압축은 합친다라는 의미를 가진다.
  * 포맷은 지운다라는 의미로 많이 사용한다. 그러나 포맷이라는 말은 파일시스템을 의미하는데 이를 더 풀어서 설명하자면 파일은 그대로 존재하지만 연결이 끊어져서 이를 읽어오지 못한다는 것이다. 파일시그니처 = 매직넘버(매직넘버를 지우게 되면 아무도 읽어오지 못한다)
  * 암호화는 수학공식에서는 이산대수문제와 소인수 분해를 많이 사용하고 절차 또한 많이 사용된다. 절차에서는 feistal 구조를 많이 사용하고 키만 둘이 알고있고 이것으로 통신한다.
<br>

**암호화 자세히 정리** <br>
 암호화할 때 사용하는 키를 암호화 키라고하고 암호를 풀 때 사용하는 키를 복호화 키라고 한다.
 두 키가 같으면 대칭키 알고리즘, 두 키가 다르는 비대칭 키 알고리즘이라고 칭한다.
<br>

1. 대칭키 알고리즘: 암호화키 = 복호화키 = 비밀키
  * ex) DES, 3DES, AES(영어표준)/ SEED, ARIA(한국어 표준)
  * 장점: 비대칭키에 비해서 연산이 빠르다. (연산 과부하가 적다는 것)
  * 단점: 키 분배가 안전하지 못 하다. 암호를 할 때 사용했던 키를 상대방에게 줘야지 암호를 풀 수 있는데 이 키를 전달하는 과장에서 다른 누구가 이 키를 가져갈 수 있으니 안전하지 못하다.
  <br>

2. 비대칭키 알고리즘: 암호화키(public key) != 복호화키(private key)
  * ex) DH(diffie hellman), RSA(암호화키와 복호화키의 역할 변경, 암호+인증)
  * 장점: 대칭키에 비해서 키분배가 안전하다. 
  * 단점: 대칭키에 비해서 연산이 느리다.

<br><br>

중요한 정보를 전송을 할 때 제3자가 도중에 암호키를 가로챌 것에 대비하여 우리는 많은 방법을 사용한다.

그 중에 하나가 hash 함수이다.
hash 함수란 단방향 함수 즉 역함수가 존재하지 않는 함수이다.
주로 무결성 체크에 사용하고 압축을 위해 사용하기도 한다.
데이터를 hash함수(md5, sha-1 등)에 집어 넣게 되면 hash code가 나오는데 md5의 경우에는 128bit의 코드가 나오고, sha-1의 경우에는 160bit의 코드가 나온다.

덩어리로 들어가면 block cipher, bit 단위로 들어가면 stream cipher가 존재한다.
현재 사용하는 대부분의 암호는 block cipher, 예전에 사용했던 대부분의 암호는 stream cipher이다. 
대표적으로 독일이 제2차 세계대전에서 사용했던 애그니마라는 암호가 있다.
stream cipher는 암호화 강도가 낮다는 단점이 있지만 연산이 빠르다는 장점이 있다.

보안을 강화하기 위해 stream cipher와 OTP와 결합해서 사용한다.
OTP는 one time password의 약자로 말 그대로 한번 사용하고 버리는 패스워드이기 때문에 상당히 강력하다.
자판기에 카드 결제를 할 때 이 방법을 사용한다고 한다.

우리나라는 대전에 원자시계가 있는데 NTP(network time protocol)  서버가 시간을 받아온다.
이후 특정서버(예: 농협은행의 서버)와 OTP의 시간을 동기화시킨다.
이 둘에는 똑같은 함수가 들어있고 시간은 서로 같기 때문에 둘이 똑같은 패스워드를 갖게 된다.
이 경우 시간이 소스값으로 들어가기 때문에 한번만 사용할 수 있는 패스워드가 되는 것이다.

<br><br>

<h3>OSI 7 Layer 계층별 정리 : L5 5계층</h3>
L5 : 연결성을 관리

http같은 경우는 연결성이 없는 stateless 통신이다.
그렇기 때문에 많은 장점들이 있는데 많은 사람들이 접속을 시도할 수 있다는 것이다.
한번 대응하고 다끊어버리기 때문에 그렇게 많은 인원들을 수용할 수 있는 것.

하지만 이런 방식으로 인터넷 쇼핑몰을 만들게 되면 문제가 발생한다.
로그인을 한 뒤 다른 상품 페이지를 클릭하면 로그인을 다시 해야하기 때문이다.
이런 문제를 해결하기 위해서는 연결성을 확보해줘야한다.
cookie로 연결성을 확보할 수 있는데 예를 들어 로그인을 하고 나면 관련정보를 인증해줄 수 있는 cookie 정보를 발부하게 되고 이 정보를 통해 연결성을 확보할 수 있는 것이다.

통신사에는 이 연결성을 책임지는 session이라는 정보들이 많이 있다.

<br><br> 

<h3>OSI 7 Layer 계층별 정리 : L4 4계층</h3>
L4: port address를 관리한다.
포트주소는 ICANN이라는 곳에서 관리하는데 16비트로 되어있어서 0번부터 65535번까지 정의되어있다.

* 255번까지는 공공의 목적으로 사용된다: HTTP80, FTP20-21, DNS53 등등 모두 공공의 목적으로 사용됨
* 1023번까지는 상용 목적이다: 넷스케이프에서 만든 웹보안 443번 사용, SSL이라고하고 이걸 표준화 시킨 것을 TLS라고 한다. (여기까지 well know port)
*  49151번까지는 등록포트이다 : 포트 간격을 위해 ICANN에다가 미리 등록하고 사용하라는 것
*  65535번까지는 임의포트이다. (나머지는 random port)

<br>

TCP라는 형태와 UDP라는 두 가지 형태로 데이터 통신을 하게된다.

1. TCP(Transmission Control Protocol)
 * 연결지향 프로토콜 connection oriented protocol
 * 사전에 미리 통신 채널를 만든다. 연결 설정, 연결유지, 연결해지
 * flow control, error control, congestion control
 * 신뢰성 있는 프로토콜: 전송이 잘되었는지 확인한다는 의미, ack라는 tcp flag 사용
 * 재전송을 요구함
 * 장거리 통신이거나 대용량일 때 사용

2. UDP(User Datagram Protocol)
 * 비연결지향 프로토콜 connectionless oriented protocol 
 * 비신뢰성 프로토콜: 상위계층에서 컨트롤하기 때문에 전송만 한다는 의미
 * 재전송 없음, 실시간 데이터이기 때문(rtp real time protocol = UDP 16384-32767)
 * 빈번한 통신, 열악한 통신환경에서 사용 : 주로 재해망, 시스템 관리에 사용
 * DNS: 13개의 서버가 있고 root DNS 서버가 존재한다.
 * cmd창에서 DNS 서버를 보기 위해서는 nslookup이라는 명령어를 사용하면된다.

<img width="457" alt="image" src="https://github.com/orieasy1/2023-2-WebStudy-backend/assets/129071350/feaf26c1-7258-4580-98c0-1bc328a9a53c">

<br>

**seq 순서번호** <br>
L5 --> L4로 내려올 때 조각화가 이루어지면 순서번호라는 것이 필요하다.
재조립, 전송확인이 제일 큰 이유이다.

1. 조각화 --> 재조립을 해서 올려보낼 때 순서번호가 있어야 순서번호대로 조립해서 올려보낼 수 있음
2. seq57 + 1 = ack58 : 순서번호에 1을 더하게 되면 ack 번호가 된다. 잘 전송받았다는 것
3. seq57 = nak57 : nak는 제대로 전송받지 못했다 및 재전송 해달라는 의미
<br>

**tcp flag**<br>
tcp flag: syn, ack, rst(reset), psh(push), urg(urgent), fin(finish)

연결설정 [syn, ack]
C ---- syn [tcp80] + 순서번호 초기화 ----> S <br>
C <-------------- rst ------------------- S (80포트가 받지못한다면 리셋)

C ---- syn [tcp80] + 순서번호 초기화 ----> S <br>
C <--------- act + window size ---------- S (통신가능한 경우) <br>
C ---------------- ack -----------------> S (총 3번 왔다갔다 수신함)

window size: 한번에 수신 가능한 데이터 크기, 수신 버퍼 크기

기본 3가지 방어가 있음 <br>
1. 보안 업데이트 --> 대기시간 줄이기
2. cookie 사용하기
3. 방화벽(FW)의 intercept 기능 사용
4. 

<br>

**실습** <br>
데이터 헤더는 wireshark를 이용해 분석할 수 있다.
<br><br>
GNS를 사용할 것이기 때문에 Npcap이 아니라 WinPcap을 다운받아줄 것이다.
Get WinPcap을 클릭하면 WinPcap 다운로드 사이트로 접속하게 되는데 여기서 다운받아준다.
그 후 다시 wireshark 다운로드 창으로 돌아와서 Npcap과 관련된 install 사항들에선 체크표시를 제거해주고 마저 다운로드 해준다.
<br><br>
wireshark를 실행시킨 후 cmd창에 들어가서 ipconfig라는 명령어를 입려갷준다.

<img width="545" alt="image" src="https://github.com/orieasy1/2023-2-WebStudy-backend/assets/129071350/ac61f845-7072-4542-817c-afdcde826a18">

그러면 위 사진과 같은 결과들이 출력될 것인데 그러면 기본 게이트웨이들 중에 항목이 채워져 있는 것이 하나 밖에 없는 것을 확인할 수 있다.
그 이름을 잘 보고 wirechark에 똑같은 이름을 가진 것이 있는지 확인한다.

현재 나의 경우에는 무선 LAN 어댑터 Wi-Fi로 표시되어있는데

<img width="804" alt="image" src="https://github.com/orieasy1/2023-2-WebStudy-backend/assets/129071350/0dd287ff-38f9-4242-8d11-85ec3cbbebef">

이미지에서 보이는 것처럼 wireshark에 Wi-fi가 있는 것을 확인할 수 있다.
이를 더블클릭하면 실시간으로 데이터를 잡고 있는것을 확인할 수 있다.

<img width="732" alt="image" src="https://github.com/orieasy1/2023-2-WebStudy-backend/assets/129071350/dc1cf1d9-e8e2-43fd-8b7a-c3af739ae70e">

여기 검색창에 해당 내용을 검색해서 우리가 필요한 내용을 뽑아낼 수 있다.

<br>

Client ------------> Server의 경우 src port : random port && dstprot : well know port
Client <------------ Server의 경우 src port : well known port && dstprot : well know port
<br>









